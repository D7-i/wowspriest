package mage

import (
	"slices"
	"time"
	
	"github.com/wowsims/classic/sim/core"
	"github.com/wowsims/classic/sim/core/stats"
)

///////////////////////////////////////////////////////////////////////////
//                            Classic Phase 1 - Molten Core
///////////////////////////////////////////////////////////////////////////

var ItemSetArcanistRegalia = core.NewItemSet(core.ItemSet{
	Name: "Arcanist Regalia",
	Bonuses: map[int32]core.ApplyEffect{
		// Increases damage and healing done by magical spells and effects by up to 18.
		3: func(agent core.Agent) {
			c := agent.GetCharacter()
			c.AddStat(stats.SpellPower, 18)
		},
		// Decreases the magical resistances of your spell targets by 10.
		5: func(agent core.Agent) {
			c := agent.GetCharacter()
			c.AddStat(stats.SpellPenetration, 10)
		},
		// Decreases the threat generated by your spells by 15%.
		8: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()
			mage.RegisterAura(core.Aura{
				Label:    "Subtlety",
				ActionID: core.ActionID{SpellID: 23545},
				Duration: core.NeverExpires,
				OnReset: func(aura *core.Aura, sim *core.Simulation){
					mage.PseudoStats.ThreatMultiplier /= 1.15
				},
			})			
		},
	},
})

///////////////////////////////////////////////////////////////////////////
//                            Phase 2 Item Sets - Dire Maul
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
//                            Phase 3 Item Sets - BWL
///////////////////////////////////////////////////////////////////////////

var ItemSetNetherwindRegalia = core.NewItemSet(core.ItemSet{
	Name: "Netherwind Regalia",
	Bonuses: map[int32]core.ApplyEffect{
		// Reduces the threat generated by your Scorch, Arcane Missiles, Fireball, and Frostbolt spells.
		3: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()
			mage.RegisterAura(core.Aura{
				Label: "Friendly Nukes",
				OnInit: func(aura *core.Aura, sim *core.Simulation) {
					for _, spell := range mage.Spellbook {
						if spell.SpellCode == SpellCode_MageFireball || spell.SpellCode == SpellCode_MageArcaneMissilesTick {
							spell.FlatThreatBonus -= 20
						}
						if spell.SpellCode == SpellCode_MageScorch || spell.SpellCode == SpellCode_MageFrostbolt {
							spell.FlatThreatBonus -= 100
						}
					}
				},
			})
		},
		// Increases the radius of Arcane Explosion, Flamestrike, and Blizzard by 25%.
		5: func(agent core.Agent) {
			// No implementation in sim
		},
		// 10% chance after casting Arcane Missiles, Fireball, or Frostbolt that your next spell with a casting time under 10 seconds cast instantly.
		8: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()
			actionID := core.ActionID{SpellID: 22008}
		
			affectedSpells := []*core.Spell{}
			netherwindFocusAura := mage.RegisterAura(core.Aura{
				Label:    "Netherwind Focus",
				ActionID: actionID,
				Duration: time.Second * 10,
				OnInit: func(aura *core.Aura, sim *core.Simulation) {
					for spellIdx := range mage.Spellbook {
						if spell := mage.Spellbook[spellIdx]; (spell.DefaultCast.CastTime > 0 && spell.DefaultCast.CastTime <= 10*time.Second) {
							affectedSpells = append(affectedSpells, spell)
						}
					}
				},
				OnGain: func(aura *core.Aura, sim *core.Simulation) {
					core.Each(affectedSpells, func(spell *core.Spell) {
						spell.CastTimeMultiplier -= 1
					})
				},
				OnExpire: func(aura *core.Aura, sim *core.Simulation) {
					core.Each(affectedSpells, func(spell *core.Spell) {
						spell.CastTimeMultiplier += 1
					})
				},
				OnCastComplete: func(aura *core.Aura, sim *core.Simulation, spell *core.Spell) {
					if !slices.Contains(affectedSpells, spell) {
						return
					}
					if (spell.CurCast.CastTime > 0) { //Returns if you are midcast when your aura procs from landing to prevent instant consumption
						return
					}
					aura.Deactivate(sim)
				},
			})
			
			mage.RegisterAura(core.Aura{
				Label:    "Netherwind Focus - Proc Aura",
				Duration: core.NeverExpires,
				OnReset: func(aura *core.Aura, sim *core.Simulation) {
					aura.Activate(sim)
				},
				OnSpellHitDealt: func(aura *core.Aura, sim *core.Simulation, spell *core.Spell, result *core.SpellResult) {
					if (spell.SpellCode == SpellCode_MageArcaneMissiles || spell.SpellCode == SpellCode_MageFireball || spell.SpellCode == SpellCode_MageFrostbolt) {
						if sim.Proc(0.10, "Netherwind Focus Proc") {
							netherwindFocusAura.Activate(sim)
						}
					}
				},
			})
		},
	},
})
///////////////////////////////////////////////////////////////////////////
//                            Phase 4 Item Sets - ZG and AB
///////////////////////////////////////////////////////////////////////////

var ItemSetIllusionistsAttire = core.NewItemSet(core.ItemSet{
	Name: "Illusionist's Attire",
	Bonuses: map[int32]core.ApplyEffect{
		// Increases damage and healing done by magical spells and effects by up to 12.
		2: func(agent core.Agent) {
			c := agent.GetCharacter()
			c.AddStat(stats.SpellPower, 12)
		},
		// Decreases the mana cost of Arcane Intellect and Arcane Brilliance by 5%.
		3: func(agent core.Agent) {
			// No implementation in sim
		},
		// Reduces the casting time of your Flamestrike spell by 0.5 sec.
		5: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()
			mage.RegisterAura(core.Aura{
				Label:    "Improved Flamestrike",
				ActionID: core.ActionID{SpellID: 24491},
				Duration: core.NeverExpires,
				OnInit: func(aura *core.Aura, sim *core.Simulation) {
					for _, spell := range mage.Spellbook {
						if spell.SpellCode == SpellCode_MageFlamestrike {
							spell.DefaultCast.CastTime -= time.Millisecond * 500
							spell.DefaultCast.GCD -= time.Millisecond * 500
						}
					}
				},
			})			
		},
	},
})

///////////////////////////////////////////////////////////////////////////
//                            Phase 5 Item Sets - AQ
///////////////////////////////////////////////////////////////////////////


var ItemSetSorcerersRegalia = core.NewItemSet(core.ItemSet{
	Name: "Sorcerer's Regalia",
	Bonuses: map[int32]core.ApplyEffect{
		// +8 All Resistances.
		2: func(agent core.Agent) {
			c := agent.GetCharacter()
			c.AddResistances(8)
		},
		// Your spellcasts have a 6% chance to energize you for 300 mana.
		4: func(agent core.Agent) {
		// No implementation in sim
		},
		// Increases damage and healing done by magical spells and effects by up to 23.
		6: func(agent core.Agent) {
			c := agent.GetCharacter()
			c.AddStat(stats.SpellPower, 23)
		},
		// +200 Armor.
		8: func(agent core.Agent) {
			c := agent.GetCharacter()
			c.AddStat(stats.Armor, 200)
		},
	},
})

var ItemSetEnigmaVestments = core.NewItemSet(core.ItemSet{
	Name: "Enigma Vestments",
	Bonuses: map[int32]core.ApplyEffect{
		// Your Blizzard spell has a 30% chance to be uninterruptible.
		3: func(agent core.Agent) {
		// No implementation in sim
		},
		// Grants +5% increased spell hit chance for 20 sec when one of your spells is resisted.
		5: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()
			actionID := core.ActionID{SpellID: 26129}

			enigmasAnswerAura := mage.RegisterAura(core.Aura{
				Label:    "Enigma's Answer",
				ActionID: actionID,
				Duration: time.Second * 20,
				MaxStacks: 4,
				OnStacksChange: func(aura *core.Aura, sim *core.Simulation, oldStacks, newStacks int32) {
					mage.AddStatDynamic(sim, stats.SpellHit, float64(-5 * oldStacks))
					mage.AddStatDynamic(sim, stats.SpellHit, float64(5 * newStacks))
				},
			})
			
			// Wowhead suggests this does not work on all spell (imp scorch and arcane missiles).  Would need testing to confirm.
			mage.RegisterAura(core.Aura{
				Label:    "Enigma Resist Bonus",
				Duration: core.NeverExpires,
				OnReset: func(aura *core.Aura, sim *core.Simulation) {
					aura.Activate(sim)
				},
				OnSpellHitDealt: func(aura *core.Aura, sim *core.Simulation, spell *core.Spell, result *core.SpellResult) {
					if result.Outcome.Matches(core.OutcomeMiss) && spell.ProcMask.Matches(core.ProcMaskDirect) {					
						enigmasAnswerAura.Activate(sim)
						enigmasAnswerAura.AddStack(sim)
					}
				},
			})
		},
	},
})

///////////////////////////////////////////////////////////////////////////
//                            Phase 6 Item Sets - Naxx
///////////////////////////////////////////////////////////////////////////

var ItemSetFrostfireRegalia = core.NewItemSet(core.ItemSet{
	Name: "Frostfire Regalia",
	Bonuses: map[int32]core.ApplyEffect{
		// Reduces cooldown on your Evocation by 1 minute.
		2: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()
			mage.RegisterAura(core.Aura{
				Label: "Evocation",
				OnInit: func(aura *core.Aura, sim *core.Simulation) {
					if mage.Evocation != nil {
						mage.Evocation.CD.Duration -= time.Second * 60
					}
				},
			})
		},
		// Gives your Mage Armor a chance when struck by a harmful spell to increase resistance against that school of magic by 35 for 30 sec. (Proc chance: 20%)
		// Fire - https://www.wowhead.com/classic/spell=28765/fire-resistance
		// Frost - https://www.wowhead.com/classic/spell=28766/frost-resistance
		// Nature - https://www.wowhead.com/classic/spell=28768/nature-resistance
		// Shadow - https://www.wowhead.com/classic/spell=28769/shadow-resistance
		// Arcane - https://www.wowhead.com/classic/spell=28770/arcane-resistance

		4: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()

			fireWardingAura := mage.RegisterAura(core.Aura{
				Label:    "Fire Resistance",
				ActionID: core.ActionID{SpellID: 28765},
				Duration: time.Second * 30,
				OnGain: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.FireResistance, 35)
				},
				OnExpire: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.FireResistance, -35)
				},
			})

			frostWardingAura := mage.RegisterAura(core.Aura{
				Label:    "Frost Resistance",
				ActionID: core.ActionID{SpellID: 28766},
				Duration: time.Second * 30,
				OnGain: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.FrostResistance, 35)
				},
				OnExpire: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.FrostResistance, -35)
				},
			})

			natureWardingAura := mage.RegisterAura(core.Aura{
				Label:    "Nature Resistance",
				ActionID: core.ActionID{SpellID: 28768},
				Duration: time.Second * 30,
				OnGain: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.NatureResistance, 35)
				},
				OnExpire: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.NatureResistance, -35)
				},
			})

			shadowWardingAura := mage.RegisterAura(core.Aura{
				Label:    "Shadow Resistance",
				ActionID: core.ActionID{SpellID: 28769},
				Duration: time.Second * 30,
				OnGain: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.ShadowResistance, 35)
				},
				OnExpire: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.ShadowResistance, -35)
				},
			})

			arcaneWardingAura := mage.RegisterAura(core.Aura{
				Label:    "Arcane Resistance",
				ActionID: core.ActionID{SpellID: 28770},
				Duration: time.Second * 30,
				OnGain: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.ArcaneResistance, 35)
				},
				OnExpire: func(aura *core.Aura, sim *core.Simulation) {
					mage.AddStatDynamic(sim, stats.ArcaneResistance, -35)
				},
			})
			
			// Wowhead suggests this does not work on all spell (imp scorch and arcane missiles).  Would need testing to confirm.
			mage.RegisterAura(core.Aura{
				Label:    "Adaptive Warding",
				Duration: core.NeverExpires,
				OnReset: func(aura *core.Aura, sim *core.Simulation) {
					aura.Activate(sim)
				},
				OnSpellHitTaken: func(aura *core.Aura, sim *core.Simulation, spell *core.Spell, result *core.SpellResult) {
					if sim.Proc(0.20, "Adaptive Warding") {
						if spell.SpellSchool.Matches(core.SpellSchoolFire) {
							fireWardingAura.Activate(sim)
							return
						}
						if spell.SpellSchool.Matches(core.SpellSchoolFrost) {
							frostWardingAura.Activate(sim)
							return
						}
						if spell.SpellSchool.Matches(core.SpellSchoolNature) {
							natureWardingAura.Activate(sim)
							return
						}
						if spell.SpellSchool.Matches(core.SpellSchoolShadow) {
							shadowWardingAura.Activate(sim)
							return
						}
						if spell.SpellSchool.Matches(core.SpellSchoolArcane) {
							arcaneWardingAura.Activate(sim)
							return
						}
					}
				},
			})
		},
		// Your damage spells have a chance to cause your target to take up to 200 increased damage from subsequent spells. (Proc chance: 20%)
		6: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()

			procAuras := mage.NewEnemyAuraArray(func(target *core.Unit) *core.Aura {
				return target.GetOrRegisterAura(core.Aura{
					Label:     "Elemental Vulnerability",
					ActionID:  core.ActionID{SpellID: 28772},
					Duration:  time.Second * 30,
					MaxStacks: 1,

					OnGain: func(aura *core.Aura, sim *core.Simulation) {
						aura.SetStacks(sim, aura.MaxStacks)

						for si := stats.SchoolIndexArcane; si < stats.SchoolLen; si++ {
							aura.Unit.PseudoStats.SchoolBonusDamageTaken[si] += 200
						}
					},
					OnExpire: func(aura *core.Aura, sim *core.Simulation) {
						for si := stats.SchoolIndexArcane; si < stats.SchoolLen; si++ {
							aura.Unit.PseudoStats.SchoolBonusDamageTaken[si] -= 200
						}
					},
					OnSpellHitTaken: func(aura *core.Aura, sim *core.Simulation, spell *core.Spell, result *core.SpellResult) {
						// OnCastComplete is called after OnSpellHitDealt / etc, so don't deactivate if it was just activated.
						if aura.RemainingDuration(sim) == aura.Duration {
							return
						}

						if result.Landed() && spell.ProcMask.Matches(core.ProcMaskDirect) {
							aura.RemoveStack(sim)
						}
					},
				})
			})

			handler := func(sim *core.Simulation, spell *core.Spell, result *core.SpellResult) {
				procAuras.Get(result.Target).Activate(sim)
			}

			core.MakeProcTriggerAura(&mage.Unit, core.ProcTrigger{
				ActionID:   core.ActionID{SpellID: 28771},
				Name:       "Elemental Vulnerability",
				Callback:   core.CallbackOnSpellHitDealt,
				Outcome:    core.OutcomeLanded,
				ProcMask:   core.ProcMaskSpellDamage,
				ProcChance: 0.2,
				Handler:    handler,
			})
		},
		// Your damage spells have a chance to displace you, causing the next spell cast to generate no threat. (Proc chance: 15%)
		8: func(agent core.Agent) {
			mage := agent.(MageAgent).GetMage()

			notThereAura := mage.RegisterAura(core.Aura{
				Label:    "Not There",
				ActionID: core.ActionID{SpellID: 28762},
				Duration: time.Second * 8,
				OnGain: func(aura *core.Aura, sim *core.Simulation) {
					mage.PseudoStats.ThreatMultiplier -= 1
				},
				OnExpire: func(aura *core.Aura, sim *core.Simulation) {
					mage.PseudoStats.ThreatMultiplier += 1
				},
				OnCastComplete: func(aura *core.Aura, sim *core.Simulation, spell *core.Spell) {
					// OnCastComplete is called after OnSpellHitDealt / etc, so don't deactivate if it was just activated.
					if aura.RemainingDuration(sim) == aura.Duration {
						return
					}
					aura.Deactivate(sim)
				},
			})

			mage.RegisterAura(core.Aura{
				Label:    "NotThere",
				Duration: core.NeverExpires,
				OnReset: func(aura *core.Aura, sim *core.Simulation) {
					aura.Activate(sim)
				},
				OnSpellHitDealt: func(aura *core.Aura, sim *core.Simulation, spell *core.Spell, result *core.SpellResult){
					if sim.Proc(0.15, "Not There") && result.Landed() && spell.ProcMask.Matches(core.ProcMaskDirect)  {
						notThereAura.Activate(sim)
					}
				},
			})
		},
	},
})